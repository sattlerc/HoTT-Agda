{-# OPTIONS  #-}

open import Base
open import Homotopy.TruncatedHIT

{-
The idea is that if [n : ℕ] and [A : Set i], then [τ n A] is defined by the
following n-truncated higher inductive type:

    module Homotopy.TruncationHIT {i} (n : ℕ) (A : Set i) where

    (n)data τ : Set i where
      proj : A → τ

More explanations on the way this is done can be found in TruncatedHIT.agda.
This file contains nothing but stuff that could (should) be autogenerated from
the three lines above.
-}

module Homotopy.TruncationHIT {i} (n : ℕ₋₂) (A : Set i) where

private
  data #τ : Set i where
    #proj : A → #τ

    #top : (f : hSⁿ n → #τ) → #τ

τ : Set i
τ = #τ

proj : A → τ
proj = #proj

top : (f : hSⁿ n → τ) → τ
top = #top

postulate  -- HIT
  rays : (f : hSⁿ n → τ) (x : hSⁿ n) → top f ≡ f x
  hack-prop : (p : n ≡ ⟨-2⟩) (x y : τ) → (x ≡ y)

#τ-rec : ∀ {j} (P : τ → Set j)
  (proj* : (x : A) → P (proj x))
  {top* : (f : hSⁿ n → τ) (p : (x : hSⁿ n) → P (f x)) → P (top f)}
  {rays* : (f : hSⁿ n → τ) (p : (x : hSⁿ n) → P (f x)) (x : hSⁿ n)
    → transport P (rays f x) (top* f p) ≡ p x}
  {hack-prop* : (p : n ≡ ⟨-2⟩) (x y : τ) (x* : P x) (y* : P y)
    → (transport P (hack-prop p x y) x* ≡ y* )}
  → ((x : τ) → P x)
#τ-rec P proj* {top*} {rays*} {hack-prop*} (#proj u) = proj* u
#τ-rec P proj* {top*} {rays*} {hack-prop*} (#top f) =
  top* f (λ x → #τ-rec P proj* {top*} {rays*} {hack-prop*} (f x))

#τ-rec-nondep : ∀ {j} (C : Set j)
  (proj* : A → C)
  {top* : (f : hSⁿ n → τ) (p : hSⁿ n → C) → C}
  {rays* : (f : hSⁿ n → τ) (p : hSⁿ n → C) (x : hSⁿ n) → top* f p ≡ p x}
  {hack-prop* : (p : n ≡ ⟨-2⟩) (x y : τ) (x* y* : C) → x* ≡ y*}
  → (τ → C)
#τ-rec-nondep C proj* {top*} {rays*} {hack-prop*} (#proj u) = proj* u
#τ-rec-nondep C proj* {top*} {rays*} {hack-prop*} (#top f) =
  top* f (λ x → #τ-rec-nondep C proj* {top*} {rays*} {hack-prop*} (f x))

private
  contr : (n ≡ ⟨-2⟩) → is-contr τ
abstract
  contr p = inhab-prop-is-contr (top (λ x → abort-nondep (transport hSⁿ p x)))
                                (all-paths-is-prop (hack-prop p))

-- Computation rules for [rays] are not needed

τ-rec :  ∀ {j} (P : τ → Set j)
  (proj* : (x : A) → P (proj x))
  {hack-prop* : (p : n ≡ ⟨-2⟩) (x y : τ) (x* : P x) (y* : P y)
    → (transport P (hack-prop p x y) x* ≡ y* )}
  (trunc : (x : τ) → is-truncated n (P x))
  → ((x : τ) → P x)
τ-rec P proj* {hack-prop*} trunc =
  #τ-rec P proj* {x₁} {x₂} {hack-prop*} where
  abstract
    u : (f : hSⁿ n → τ) (p : (x : hSⁿ n) → P (f x))
      → filling-dep n P f (top f , rays f) p
    u = truncated-has-filling-dep τ P n contr (λ f → (top f , rays f))

    x₁ : (f : hSⁿ n → τ) (p : (x : hSⁿ n) → P (f x)) → P (top f)
    x₁ = λ f p → π₁ (u f p)

    x₂ : (f : hSⁿ n → τ) (p : (x : hSⁿ n) → P (f x)) (x : hSⁿ n)
      → transport P (rays f x) (x₁ f p) ≡ p x
    x₂ = λ f p → π₂ (u f p)

τ-rec-nondep : ∀ {j} (C : Set j)
  (proj* : A → C)
  {hack-prop* : (p : n ≡ ⟨-2⟩) (x y : τ) (x* y* : C) → x* ≡ y*}
  (trunc : is-truncated n C)
  → (τ → C)
τ-rec-nondep C proj* {hack-prop*} trunc =
  #τ-rec-nondep C proj* {λ _ p → π₁ (u p)}
                        {λ _ p → π₂ (u p)} {hack-prop*} where
  u : _
  u = truncated-has-spheres-filled n _ trunc

-- The nth truncation is of h-level [n]
abstract
  τ-is-truncated : is-truncated n τ
  τ-is-truncated =
    spheres-filled-is-truncated n τ contr (λ f → (top f , rays f))
